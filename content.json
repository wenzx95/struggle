{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/struggle/2021/01/15/hello-world/"},{"title":"RabbitMQ","text":"[TOC] # AMQP架构图1234graph LRA[Producer] --&gt; B[Exchange1]B -- RoutingKey ---&gt; C[Queue1]C --&gt; D[Consumer] 1、Exchange 交换器​ 生产者发送消息指定交换器的名字，当交换器收到消息的时候，根据消息中的路由键(RoutingKey)和交换器的类型规则以及绑定键（BindingKey），路由到一个或者多个队列中。每个符合的Queue都会进行发送 主要方法如下： 1channel.basicPublish(String ExchangeName, String RouteKey, Map props, byte[] Msg) 交换器类型： direct：只有当RoutingKey 和BindingKey完全匹配的时候，消息才能够路由到相应的Queue中 topic：根据一系列匹配规则进行消息分发 RoutingKey 和 BindingKey 都是以一系列为”.”分隔的单词串 BindingKey 中*匹配一个单词，#匹配多个单词 header：根据header信息分发消息，但性能很差，一般不用 fanout：没有规则，所有的都会分发到所有的Queue中 2、Queue 队列​ RabbitMQ的内部对象，存放消息的地方，所有的消息只能存放到队列中，消费者订阅队列消费消息。当一个队列有多个消费者订阅时，队列中的消息会进行平均均摊到每个消费者中。 3、RabbitMQ流程​ 生产者连接到RabbitMQ Broker上，建立一个Connection ,并且开启一个Channel信道。之后声明一个Exchange，Queue，并且通过BindingKey 进行绑定。当生产者通过Channel把消息发过来时，消息包含Exchange Name,RoutingKey 和消息体。通过交换器的名称，将消息发送到对应的交换器中，然后交换器通过RoutingKey 和 BindingKey的比对，将消息发送到对应Queue中。当生产者接受到发送消息到Ack时，关闭信道，关闭连接。 ​ 消费者订阅队列，同样的建立Connection连接，并开启一个Channel信道，消费者想Broker中请求订阅消息，并可能设置回调函数等待MQ中的消息推送过来。Broker投递队列中的消息，消费者接受应答，并返回Ack确认接受到的消息，MQ删除队列中相应的消息，关闭Channel信道和Connection连接。 4、消息的可靠性4.1 生产者到交换器1、事务机制 123channel.txSelect()channel.txCommit()channel.txRollback() ​ txSelect先将chennel设置为事务模式，设置为事务模式后，继续channel.basicPublish()发送消息，发送成功后调用channel.txCommit()提交消息，当事务提交成功的时候，消息一定到达了MQ。当在发送消息途中或者提交之前发生异常，可以通过try..catch..进行捕获，并且调用channel.txRollback()进行消息回退。 Tx.Commit时序图 12345Producer -&gt; Broker:Tx.SelectBroker -&gt; Producer:Tx.Select-OKProducer -&gt; Broker:basic.PublishProducer -&gt; Broker:Tx.CommitBroker -&gt; Producer:Tx.Commit-OK Tx.Rollback时序图 12345Producer -&gt; Broker:Tx.SelectBroker -&gt; Producer:Tx.Select-OKProducer -&gt; Broker:basic.PublishProducer -&gt; Broker:Tx.RollbackBroker -&gt; Producer:Tx.Rollback-OK 2、Confirm确认机制 123channel.confirmSelect()channel.addConfirmListener(new ConfirmListener())channel.waitForConfirms() ​ channel.confirmSelect()将信道设置为confirm模式，当信道设置为confirm模式的时候，信道上的消息便会指派一个唯一的id,当消息发送到交换器的时候，Broker会返回包含id的确认信息，生产者接受到Ack信息后就可以知道哪些消息到达。当队列是持久化的时候，消息写入到磁盘时才会返回AcK信息。channel.waitForConfirms()会进行阻碍同步，当接受到全部的Ack确认的时候，才会继续执行下去。当存在nack的时候，channel.waitForConfirms()返回false,可以进行重新发送。 123456Producer -&gt; Broker:Confirm.SelctBroker -&gt; Producer:Confirm.Select-OKProducer -&gt; Broker:basic.PublishBroker -&gt; Producer:Basic.AckProducer -&gt; Broker:basic.PublishBroker -&gt; Producer:Basic.Ack 4.2 交换器到队列​ 备份交换器（Alternate Exchange），在声明交换器到时候，添加alternate-exchange参数，当消息到交换器到时候，通过规则找不到可以路由到交换器，则会被路由到备份交换器AE中，路由键和原先的路由键一致。通过将AE设置为fanout类型，并且添加持久化队列，确保消息能一定分发到队列上并持久化。 4.3 队列到消费者​ 消费者在订阅队列的时候，可以设置AutoAck是否自动确认。如果需要保证消息100%到达，需要设置AutoAck为false，然后在收到消息后，手动进行Ack确认，当MQ收到Ack确认后，才会把消息从内存中或者磁盘中删除。如果AutoAck设置为true，RabbitMQ会自动把发送出去的消息置为默认，从内存或者磁盘中删除消息，而不管消费者是否接受到消息。 ​ 当AutoAck设置为false的时候，这个时候队列中的消息就分成了两部分消息，一部分是还没有发送的消息，另一部分是发送后消费者未Ack的消息，反映在WebUI上就是Unacked消息。RabbitMQ只有当这个消费者失去连接后，Unacked消息才会重新进行队列中进行新一轮的投递，因为RabbitMQ允许消费者消费很长很长的时间。 123Broker -&gt; Consumer:Basic.ConsumerConsumer -&gt; Broker:Basic.Consumer-OKConsumer -&gt; Broker:Basic.Ack 4.4 死信队列接受拒绝消息，方便拒绝信息12channel.basicReject(long deliveryTag, boolean requeue)channel.basicNack(long deliveryTag, boolean multiple, boolean requeue) ​ 在AutoAck设为false的基础上，消费者在接受到消息的时候，如果不方便确认，可以对消息进行拒绝处理。可以采用channel.basicReject方法进行单条拒绝，如果需要拒绝多条的话，可以调用channel.basicNack()方法进行批量拒绝，当第二个参数multiple为true的时候，代表在这条消息之前的都拒绝掉。requeue 参数代表被拒绝掉的消息是否重新入列投递。 ​ 当requeue设置为false的时候，便可以启用死信队列来记录被拒绝的消息，方便后续排查。 5、特殊队列5.1、死信队列 x-dead-letter-exchange​ 在声明队列时，添加参数x-dead-letter-exchange:exchangeName，当该队列上的消息被消费者拒绝时并且未重新入列的时候，就会被转发到x-dead-letter-exchange配置的DLX交换器上，将其类型设置为fanout,保证消息一定到达后续的队列中。和DLX交换器绑定的队列称之为死信队列。 ​ 下列几种情况下消息会被转发到死信队列中 被拒绝的消息Reject和Nack TTL时间过期的消息 队列超过最大长度 5.2、延时队列​ 可以通过死信队列外加TTL的思想，来实现。将消息发送到一个无消费者的队列中，然后设置队列的过期时间，并且配置DLX死信队列。当消息在延时队列中等待时间到期后，将会转发到DLX死信队列中，这个时候，消费者通过去订阅死信队列，便可以实现延迟队列的效果。 队列TTL 通过设置x-expires:xxx参数，来设定队列的到期时间，xxx的单位为毫秒。 消息TTL 通过对消息发送时设置x-messgae-ttl:xxx参数来设置消息的到期时间，xxx的单位为毫秒 ​ 当即设置了队列了TTL，又设置消息的TTL时，这个时候消息取两者最低的TTL，作为过期时间。","link":"/struggle/2021/01/15/RabbitMQ/"}],"tags":[],"categories":[]}